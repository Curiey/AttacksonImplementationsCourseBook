<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch003.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="temporal-side-channels-i" class="level1" data-number="2">
<h1 data-number="2">Temporal Side Channels I</h1>
<section id="history" class="level2" data-number="2.1">
<h2 data-number="2.1">History</h2>
<p>In 1995, at the age of 22, Paul Kocher released a paper called Timing Attacks on Implementations of Diffie-Helman, RSA, DSS and other systems <span class="citation" data-cites="kocher1996timing"></span>.</p>
<p>Before it was published, he wrote about it in a mailing list of Cypherpunks<a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> which included all sorts of people like mathematicians, photographers, artists anarchists and more. The attack was first demonstrated in 1997 at a cryptography conference. And later, in 1998 an academic paper was published describing how to perform the attack. In 2003 and 2007 this kind of attack was used to break SSL.</p>
</section>
<section id="the-threat-model" class="level2" data-number="2.2">
<h2 data-number="2.2">The Threat Model</h2>
<p>The objective of the attacker is to discover the password. The attacker goes about this by sending unlimited queries and measures their time. Unlimited queries are not always possible. Some devices are disabled after three to five tries. The same applies to time measurements. However the assumption is that these are possible according to Kerckhoffs’s principle(law), that states that everything except the key is public knowledge.</p>
<p>Figure <a href="#c1_fig_threat_model" data-reference-type="ref" data-reference="c1_fig_threat_model">2.1</a> describes the Threat Model on an implementation of a secure system. It is important to mention that we’re talking about attacking an implementation, and not the algorithm itself as we consider the algorithm or protocol being examined as completely secure.</p>
<figure>
<img src="../media/file8.png" id="c1_fig_threat_model" alt="The Threat Model. Image from JF Dhem1998. The attacker can send a message to the implementation and get an answer from it. Also - the attacker is able to measure the time it takes for the implementation to compute the output" /><figcaption aria-hidden="true">The Threat Model. Image from JF Dhem1998. The attacker can send a message to the implementation and get an answer from it. Also - the attacker is able to measure the time it takes for the implementation to compute the output</figcaption>
</figure>
<section id="when-is-a-timing-attack-even-possible" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1">When is a timing attack even possible?</h3>
<ol>
<li><p>Physical access to the device. (for example: Smart card, Crypto wallet, Electronic voting machines)</p></li>
<li><p>Sharing a virtual machine with the service (for example: Swiping a credit card)</p></li>
<li><p>Remote access to a device (access to a device over the network, which may be very noisy and may be rather difficult to implement)</p></li>
</ol>
</section>
</section>
<section id="timing-attack" class="level2" data-number="2.3">
<h2 data-number="2.3">Timing attack</h2>
<p>A timing attack is based on the time it takes to complete an algorithm.</p>
<figure>
<img src="../media/file9.png" id="c1_fig_pass_check_1" alt="A simple and efficient password checking algorithm. In line 4 there’s a check if there length of the password is the same as the length of the input. In line 8 there’s an iteration over all of the characters in the password " /><figcaption aria-hidden="true">A simple and efficient password checking algorithm. In line 4 there’s a check if there length of the password is the same as the length of the input. In line 8 there’s an iteration over all of the characters in the password </figcaption>
</figure>
<p>Consider the algorithm for password checking as described in figure <a href="#c1_fig_pass_check_1" data-reference-type="ref" data-reference="c1_fig_pass_check_1">2.2</a></p>
<p>In a scenario where a timing attack is not possible, breaking the password requires the attacker to bruteforce the password, checking every possible string for one successful attempt.</p>
<p>Let’s assume the password is the length of 16 characters, and if the password only contains english upper-case characters we have 26 possible values for each of the 16 characters in the password. The first character has 26 possiblites, the second has 26 possiblites and so on. So bruteforcing a password like this requries <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>26</mn><mn>16</mn></msup><annotation encoding="application/x-tex">{26}^{16}</annotation></semantics></math> different attempts, which cannot be completed by any computer in a decent amount of time. In general, for a password of length <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> and character range of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, breaking the password will take <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O({k}^{n})</annotation></semantics></math> attempts.</p>
<p>Now let’s consider the scenrio where <strong>a timing attack is possible</strong>. To perform a timing attack, the attacker takes advantage of the fact that when the program checks for strings equality, the comparison will finish as soon as it finds one character that doesn’t match. Consider the following example where the attacker tries the 3 following attempts and measures the time it takes for the machine to respond. The attacker tries "AAAA" and measures 0.2ms, then tries "BAAA" and measures 0.5ms lastly tries "CAAA" and measures 0.2ms again. The attack can be pretty sure that the first character is "B". Now, checking the whole password does not require iterating of all possible combinations of strings of size <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>. All it takes is to iterate over all possible values of each character, say <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>, and repeat that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> times. This results in a total runtime of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mi>k</mi><mo>+</mo><mi>k</mi><mo>+</mo><mi>…</mi><mo>=</mo><mi>n</mi><mi>k</mi><mo>=</mo><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">k+k+k+\dots = nk = O(n)</annotation></semantics></math></p>
<p>We can now break the password in a reasonable amount of time, even without knowing the length of the password we’re trying to crack.</p>
</section>
<section id="timing-attack-defenses" class="level2" data-number="2.4">
<h2 data-number="2.4">Timing Attack Defenses</h2>
<p>After discussing the potential of such attack, we now consider the possible mitigations we can implement on our system to prevent such attacks.</p>
<section id="mitigation" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1">Mitigation</h3>
<p>We can consider adding a random wait time after checking each one of the characters. The problem of course is that the whole process of checking for a valid password becomes slower. And of course, if the attacker can perform a lot of measurements on our system, since the noise is random, the attacker would be able to ignore it.</p>
</section>
<section id="prevention" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2">Prevention</h3>
<p>The second type of countermeasure is prevention, making sure that our system is completely resistant to timing attacks.</p>
<section id="prevention-method-1-padding" class="level4" data-number="2.4.2.1">
<h4 data-number="2.4.2.1">Prevention Method 1: Padding</h4>
<figure>
<img src="../media/file10.png" id="c1_fig_pass_check_2" alt="Prevention method 1, padding the user guess and the secret password to the same length and check all characters even if there’s a mismatch in the first character." /><figcaption aria-hidden="true">Prevention method 1, padding the user guess and the secret password to the same length and check all characters even if there’s a mismatch in the first character.</figcaption>
</figure>
<p>The first method we examine is to pad the secret password and the user’s guess to the same length. Also - the function dosen’t exit as soon as we see a character mismatch. The code is described in figure <a href="#c1_fig_pass_check_2" data-reference-type="ref" data-reference="c1_fig_pass_check_2">2.3</a></p>
<p>The problem with this implementation is that every time there’s a character mismatch we execute additional code, which is loading the variable <code>result</code> and writing the value <code>false</code> to it. This may seem insignificant in the beginning but actually, this makes our code <strong>much more vulnerable than it was before</strong>. As now the time it takes for the entire function to complete is linearly dependant on the amount of characters mismatches we have, this allows an attacker to perform the same attack from before with no significant changes to his original timing attack.</p>
<p>One might think of a fix which is adding another branch to the <code>if</code> statement that will do some garbage operation like <code>foo = false</code> just so that the attacker might not be able to distinguish between a match and a mismatch. The problem with this fix might be that the access time to one variable may be different than the access time to another variable, and the attacker will be able to tell the difference between them.</p>
</section>
</section>
<section id="prevention-method-2-hashing" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3">Prevention Method 2: Hashing</h3>
<figure>
<img src="../media/file11.png" id="c1_fig_pass_check_3" alt="Secure password checking using a secure hash function" /><figcaption aria-hidden="true">Secure password checking using a secure hash function</figcaption>
</figure>
<p>The right way to store passwords is with hashing (storing the hash of the password rather than the password in plain text). A hash is a cryptographic function which has the property called "The Avalanche Property" which means if even 1 bit is fliped in the input, at least half of the bits of the output are flipped as a result. This means that even if my guess is really close to the password (1 bit away from the real password) I cannot really know which bits are correct and which are not due to the Avalanche property.</p>
<p>Using hashes to perform a secure password check is described in the algorithm in figure <a href="#c1_fig_pass_check_3" data-reference-type="ref" data-reference="c1_fig_pass_check_3">2.4</a> A guess is being hashed before it is compared against the hash of the true password. An attacker might use the same methods as described previously to try to leak the hash of the true password, but that would be very difficult as the attacker does not input the hash, the attacker only controls a string that is later being hashed by the algorithm. So trying the previous methods to leak the password would not work assuming the hash function is propely implemented.</p>
<p>A possible leak occuring from this method is the length of the true password. In line 7 of the algorithm in figure <a href="#c1_fig_pass_check_3" data-reference-type="ref" data-reference="c1_fig_pass_check_3">2.4</a> the hash of the true password is computed. Line 7 makes the total run time of the program dependent upon the length of the true password. While this might be risky, this is easy to fix - we can just precompute the hash of the true password and use it whenever the algorithm runs. This is done for example in Linux where the hashes of user’s passwords are stored in a file in <code>/etc/shadow</code>.</p>
</section>
</section>
<section id="the-algebra-behind-rsa" class="level2" data-number="2.5">
<h2 data-number="2.5">The Algebra Behind RSA</h2>
<p>The next thing we’re going to perform is a timing attack on the RSA crypto system. But before we dive into how we break RSA (next chapter) we’re going to discuss the algebraic foundation of RSA <span class="citation" data-cites="kaliski2006mathematics"></span>.</p>
<p>The RSA cryptosystem lives in something called a multiplicative group. The group that is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Z</mi><mi>n</mi><mo>*</mo></msubsup><annotation encoding="application/x-tex">Z^{*}_n</annotation></semantics></math>.</p>
<p>We take 2 random prime numbers; <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math> and assign <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">n=pq</annotation></semantics></math>. The group <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Z</mi><mi>n</mi><mo>*</mo></msubsup><annotation encoding="application/x-tex">Z^{*}_n</annotation></semantics></math> contains all the numbers from 1 to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> which do not divide <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> (that is, do not divide <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>). For example: for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">p=3</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">q=5</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn><mo>*</mo><mn>5</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">n= 3*5 = 15</annotation></semantics></math> so <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Z</mi><mi>n</mi><mo>*</mo></msubsup><mo>=</mo><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>11</mn><mo>,</mo><mn>13</mn><mo>,</mo><mn>14</mn><mo stretchy="false" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">Z^{*}_n = {\{1,2,4,7,8,11,13,14\}}</annotation></semantics></math>.</p>
<p>Like all groups, this group has the associative operation which in our case is the modular multiplication, that is because, as we mentioned before,this group is a multiplicative group. The group is also closed under that operation.</p>
<p>The group also has an identity element, 1. Which when multiplied by another element from the group - does not change it.</p>
<p>The last property this group has is that every element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math> in the group has an inverse element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∈</mo><msubsup><mi>Z</mi><mi>n</mi><mo>*</mo></msubsup></mrow><annotation encoding="application/x-tex">r^{-1} \in Z^{*}_n</annotation></semantics></math> so that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>*</mo><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r*r^{-1}=1</annotation></semantics></math>.</p>
<p>Since the exponentiation is just repeated multiplication - we consider exponentiation to also be a closed operation under that group. Each element has an order, the order always divides <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(p-1)(q-1)</annotation></semantics></math> (Fermat’s little theorem). When the element is raised to the power of the order, the result of the exponentation (under the modulu of course) is 1, the identity element in the group.</p>
<p>It also important to note that we cannot compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(p-1)(q-1)</annotation></semantics></math> from knowing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math></p>
<section id="elementary-operations-of-rsa" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1">Elementary Operations of RSA</h3>
<p>To use the RSA crypto system to encrypt and decrypt messages you first have to generate the infrastructure, that means deciding on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>, both large prime numbers and computing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">n = pq</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(p-1)(q-1)</annotation></semantics></math> denoted as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(n)</annotation></semantics></math></p>
<ul>
<li><p><strong>Choosing a public and private key pairs</strong> Choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>∈</mo><msubsup><mi>Z</mi><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><mo>*</mo></msubsup></mrow><annotation encoding="application/x-tex">e \in Z^{*}_{\phi(n)}</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>∈</mo><msubsup><mi>Z</mi><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><mo>*</mo></msubsup></mrow><annotation encoding="application/x-tex">d \in Z^{*}_{\phi(n)}</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ed = 1</annotation></semantics></math> mod <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\phi(n)</annotation></semantics></math>. The public key is the pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mrow><mi>n</mi><mo>,</mo><mi>e</mi></mrow><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle{n,e}\rangle</annotation></semantics></math> and the private key pair is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mrow><mi>n</mi><mo>,</mo><mi>d</mi></mrow><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle{n,d}\rangle</annotation></semantics></math>.</p></li>
<li><p><strong>To encrypt a message</strong> Choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><msubsup><mi>Z</mi><mi>n</mi><mo>*</mo></msubsup></mrow><annotation encoding="application/x-tex">m \in Z^{*}_n</annotation></semantics></math> as your message. The cipher is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>m</mi><mi>e</mi></msup><annotation encoding="application/x-tex">m^{e}</annotation></semantics></math> mod <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math></p></li>
<li><p><strong>To decrypt a message</strong> Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msup><mi>m</mi><mi>e</mi></msup></mrow><annotation encoding="application/x-tex">c = m^{e}</annotation></semantics></math> mod <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, perform <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mi>d</mi></msup><annotation encoding="application/x-tex">c^{d}</annotation></semantics></math> = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>m</mi><mrow><mi>e</mi><mi>d</mi></mrow></msup><annotation encoding="application/x-tex">m^{ed}</annotation></semantics></math> = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>m</mi><mn>1</mn></msup><annotation encoding="application/x-tex">m^{1}</annotation></semantics></math> = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> mod <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math></p></li>
</ul>
<p>Example: Consider <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">p = 3</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">q = 5</annotation></semantics></math>. So we can compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn><mo>*</mo><mn>5</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">n = 3*5 = 15</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false" form="prefix">(</mo><mn>15</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>2</mn><mo>*</mo><mn>4</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">\phi(15) = 2 * 4 = 8</annotation></semantics></math> Let’s assume we choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">e = 3</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">d=11</annotation></semantics></math>. We consider the message 2.</p>
<p>To encrypt, we compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^{3} = 8</annotation></semantics></math> mod 11, Which is the cipher.To decrypt, we’re using the private key <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>11</mn><annotation encoding="application/x-tex">11</annotation></semantics></math> as follows: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>8</mn><mn>11</mn></msup><annotation encoding="application/x-tex">8^{11}</annotation></semantics></math> = 2 mod 15. Now we have our message back, 2.</p>
<p>Since this is not a crypto course, we will not go into any more details about the algebra behind RSA. However it is important for us to familiarize ourselves with the basics of RSA in order to understand later how it was optimized and how can we break it.</p>
</section>
<section id="research-highlights-1" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2">Research Highlights</h3>
<p>Timing and side channel attacks are well-known concepts in computer security and have been used to attack many kinds of systems, among those systems are cryptographic implementations, OpenSSL, SSH sessions, web applications and virtual machine environments. The following subsection will be devoted to showcase inspired works on some of the susceptible systems mentioned above. As mentioned at the beginning of the chapter, one of the pioneers to interduce these of attacks is Paul C Kocher in his paper  <span class="citation" data-cites="kocher1996timing"></span>. He described the ability of an adversary to find the private key of a cryptosystem by carefully measuring the amount of time required to perform private key operations. Another interesting work was done by D. Brumley et. al.  <span class="citation" data-cites="brumley2005remote"></span> who expanded the concept of timing attacks to apply for general software systems. Specifically, he and his colleagues devised a timing attack against OpenSSL. Through experiments they showed that they can extract private keys from an OpenSSL-based web server running on a machine in the local network. D. X. Song et. al.  <span class="citation" data-cites="song2001timing"></span> showed that using statistical techniques on timing information received through exploitation of two relatively minor weaknesses in SSH can lead to exfiltration of users typing in SSH session. In recent years, a wide variety of defense methods to protect both user space and kernel space code have been developed. As such, the attack surface of conventional exploitation strategies has been reducing significantly. Thus, both user space and kernel space code have become a target of timing side channels attacks. Hund et. al.  <span class="citation" data-cites="hund2013practical"></span> presented that an adversary can implement a timing attack against the memory management system to deduce information about the privileged address space layout.</p>
</section>
<section id="see-also" class="level3" data-number="2.5.3">
<h3 data-number="2.5.3">See also</h3>
<ol>
<li><p>John Wiley and Sons Chichester , "Overview about Attacks on Smart Cards by Wolfgang Rankl, Munich", 3rd edition at John Wiley and Sons in September 2003.</p></li>
<li><p>Thomas Popp, "An Introduction to Implementation Attacks and Countermeasures", Graz University of Technology, Institute for Applied Information Processing and Communications (IAIK) Graz, Austria.</p></li>
</ol>
</section>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>A cypherpunk is any activist advocating widespread use of strong cryptography and privacy-enhancing technologies as a route to social and political change. Originally communicating through the Cypherpunks electronic mailing list, informal groups aimed to achieve privacy and security through proactive use of cryptography<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
