<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch007.xhtml</title>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="chap:c7_cacheattacks" class="level1" data-number="6">
<h1 data-number="6">Introduction to micro-architectural attacks</h1>
<p>Clementine Maurice, CNRS, IRISA<br />
April 30, 2019 — Ben Gurion University, Israel</p>
<section id="sec:BackgroundnPrimitives" class="level2" data-number="6.1">
<h2 data-number="6.1">Background &amp; Primitives</h2>
<p>Micro-architectural side-channel attacks refer to a side-channel attack that exploit information leakage from the hardware infrastructure itself. The attacks can be found in a large scope of devices - servers, workstations, laptops, smart-phones, etc.</p>
<p>Normally, we assume a safe software infrastructure, meaning that no software bugs, such as buffer overflow, is present. Nevertheless, such assumption does not imply safe execution, due to the fact that the information leaks because of the implementation, which is often driven by complex optimizations and design. Such leakages are not considered as ’mistakes’ or ’bugs’, but rather a trade-off decision between optimizing some aspects of the execution and potential information leakage.</p>
<p>Potential outcomes of such attacks as described can be crypto primitives, which is common with other side-channel attacks, but also other sensitive information such as keystrokes and mouse movements.</p>
<p>In terms of sources of leakage, we saw in previous chapters sources such as power consumption or electromagnetic leaks. However it’s harder for an attacker to come across such sources because they require physical proximity and access to the device, which are more typical to embedded devices. In this case the requirement is that the attacker will have somewhat remote access to the device, meaning that the attacker can run code on the hardware infrastructure of the machine. Such scenarios can be found in cloud providers renting computational resources to a costumer, Java-Script code running in a browser and others.</p>
<section id="subsec:CacheattackonRSA" class="level3" data-number="6.1.1">
<h3 data-number="6.1.1">Example: Cache attack on RSA Square-and-Multiply Exponentiation</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>←</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">X \leftarrow 1</annotation></semantics></math> <span><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>←</mo><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X \leftarrow multiply(X,X)</annotation></semantics></math> <span><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>←</mo><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X \leftarrow multiply(X,b)</annotation></semantics></math></span></span> <strong>return</strong> X</p>
<p>Consider the binary exponentiation algorithm presented in Algorithm <a href="#algo:SaM" data-reference-type="ref" data-reference="algo:SaM">[algo:SaM]</a>. Notice that the execution flow of the algorithm relies heavily on the value of the bit <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mi>i</mi></msub><annotation encoding="application/x-tex">e_i</annotation></semantics></math> of the private key. Now consider a scenario in which an attacker has information on the changes regarding the buffer holding the multiplier <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>. Such information can be considered as a query to the buffer and receiving as a result the latency of the query. If the buffer is in use, the query will be longer than if the buffer is unused.</p>
<figure>
<img src="../media/file62.png" id="fig:PPSQ" alt="Querying the buffer holding the multiplier b. The y axis is a latency scale, and the x axis represent the query index. The dotted plot is a scatter plot while the solid line is the normalized moving average." /><figcaption aria-hidden="true">Querying the buffer holding the multiplier <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>. The y axis is a latency scale, and the x axis represent the query index. The dotted plot is a scatter plot while the solid line is the normalized moving average.</figcaption>
</figure>
<p>In , the graph of the querying result, the actual bits of the exponent can be clearly detected.</p>
</section>
<section id="subsec:attackmodel" class="level3" data-number="6.1.2">
<h3 data-number="6.1.2">Attack Model</h3>
<p>We assume that the attacker has no physical access to the device. Moreover, the attacker can only execute unprivileged code on the same machine as the victim. Such scenarios in which this happens can be found, for example, when the victim installs some malicious program on his machine/smartphone. Other examples can be found in cloud computing where an attacker has a virtual machine on the same physical machine as the victim, or in a web environment in which the attacker runs unprivileged JavaScript code.</p>
<p>In the scope of this chapter we will focus on shared hardware in the form of data/instructions that are stored in the cache. While other shared hardware components can also include the DRAM and the memory bus (memory shared hardware) or the branch prediction unit and the arithmetic logic unit (CPU shared hardware), they are not in the scope of this chapter.</p>
</section>
<section id="subsec:todaycpucomplex" class="level3" data-number="6.1.3">
<h3 data-number="6.1.3">Today’s CPU Complexity</h3>
<p>From 2012 Intel has released a new family of microprocessors every year. Each comes with its own new microarchitectural schemes with new characteristics. To gain performance upgrade in each new installment (on average 5% increase in performance depending on the feature), minor optimizations, such as caches and branch prediction units are added. Such optimizations are the main reason that side-channel information leakage exists. Unfortunately, these optimizations often come with no documentation since this is Intel intellectual property. Lack of documentation can make it harder for an attacker to perform said side-channel attacks.</p>
<p>To emphasize today’s CPU complexity, it is said that “Intel x86 documentation has more pages than the 6502 has transistors" <span class="citation" data-cites="IntMan"></span>, with 6502 being a reference to a 8-bit microprocessor, used in Apple II, Commodore 64, Atari 800 and more. It had, in the year 1975, roughly 3510 transistors, while the Intel Software Developer’s Manuals is 4844 pages (may. 2018). In a more advance microprocessor, such as the 22-core Intel Xeon Broadwell-E5, more than 7 billion transistors can be found.</p>
</section>
<section id="subsec:backgroundoncaches" class="level3" data-number="6.1.4">
<h3 data-number="6.1.4">Background on Caches</h3>
<p>When designing a cache side-channel attack, a proper understanding of how caches work, in detail, is required. First, we need to acknowledge that the requirements for an ’ideal memory’ oppose each other. Such requirements are zero latency, infinite capacity, zero cost and infinite bandwidth. The trade-offs are interconnect: <strong>Bigger is Slower</strong> - Bigger memory often comes with higher latency, due to the fact that it would take longer to determine the location to retrieve. <strong>Faster is Expensive</strong> - A reduction in latency often means that a more expensive technology is needed. For example, SRAM is faster than DRAM, which in turn is faster than Disk memory. However, their cost ratio is the other way around. <strong>Bandwidth is Expensive</strong> - A wider bandwidth needs to come with additional banks, ports, higher frequency or faster technology.</p>
<p>In our need to understand the use of cache, we need to examine the different memory technologies and why they are used in the way they are used. <strong>DRAM</strong> - Dynamic Random Access Memory is the technology that is often used as the main memory (or RAM), while <strong>SRAM</strong> - Static Random Access Memory is the technology used in cache memory. The DRAM latency is higher than the SRAM latency, but is cheaper to make. The main difference in cost arises from the fact that DRAM consists only of one transistor and one capacitor per cell, while the SRAM consists of six transistors per cell. These differences also mean that the DRAM is more dense. Finally, the DRAM cell layout and technology requires to periodically refresh each cell.</p>
<p>Since having Both a large and fast, single level of memory is unlikely, CPU’s today are made with multiple levels of storage. The main idea is that progressively bigger and slower storage units are located in higher levels of memory, which are farther from the processor. The motivation for such design is to ensure that most of the data the processor needs is kept in the closer and faster levels.</p>
<figure>
<img src="../media/file63.png" id="fig:MemHier" alt="Memory Hierarchy of a common CPU." /><figcaption aria-hidden="true">Memory Hierarchy of a common CPU.</figcaption>
</figure>
<p>The memory hierarchy can be seen in , where data can reside in, at a given point in time, in the following storage units - in CPU registers, the different levels of the CPU cache, main memory or disk memory.</p>
</section>
<section id="subsec:cachingbasics" class="level3" data-number="6.1.5">
<h3 data-number="6.1.5">Caching Basics</h3>
<p>The two main ideas of caching are to exploit temporal and spatial locality. <strong>Temporal Locality</strong> is the notion that a program tends to reference the same memory location many times within a small window of time (for example, loops). The anticipation of such thinking is that recently accessed data will be accessed again soon. Therefor, a good strategy will be to store recently accessed data in automatically managed fast memory. <strong>Spatial Locality</strong> is the notion that a program tends to reference a cluster of memory locations at a time (for example, sequential instruction access or array traversal). The anticipation will be that surrounding of some accessed data will be accessed soon. A good strategy will consider storing addresses adjacent to the recently accessed one in an automatically managed fast memory. In detail, we want to logically divide memory into equal size blocks (lines) and fetch to cache the accessed block in its entirety.</p>
<p>Moreover, there are two approaches to the management scheme, manual and automatic. <strong>Manual Management</strong> means that the programmer manages data movement across levels, which is not scalable for substantial programs. However, it is sometimes used in some embedded systems. <strong>Automatic management</strong> refer to a scheme in which the hardware itself manages data movement across the different levels in a way that is transparent to the programmer. Meaning that the average programmer does not need to know anything related to the memory hierarchy levels to write a program. On the down side, which begs the question on how to write a fast program if the management is automatic, in addition to what kind of side-channels could arise from such scenario.</p>
<p>The basic unit of storage in the cache is called a block or a line. The main memory is logically divided into cache blocks that map to locations in the cache. And when data is referenced, two outcomes can come of such action - a cache hit or a cache miss. A <strong>Cache Hit</strong> occurs when a line is referenced and is in the cache. The cached data will be retrieved instead of accessing main memory. A <strong>Cache Miss</strong> occurs when a line is referenced and is not in the cache. The data will be fetched from main memory, passing through the cache, possibly evict other line to ensure enough storage.</p>
<p>When designing a cache, we are faced with a number of design decisions to handle. <strong>Placement</strong> - Essentially the location in which we will place or find a block in the cache. <strong>Replacement</strong> - We need often to remove data from the cache to make room for newer data. Which begs the question of what data to evict. <strong>Granularity of Management</strong> - The basic units of storage in different levels. Do we store the same amount of blocks across different levels or do we uniformly store the same size of blocks. <strong>Write Policy</strong> - When a write operation is being made, we need to decide whether to preform the write operation in all levels or pass the write data to a lower level only upon eviction from that level. <strong>Instruction/Data</strong> - When a program is executing, the instructions that are in need to be executed are required to be fetched from memory as well. The designer needs to decide whether to treat instructions and data memory as two separate types or as the same.</p>
</section>
<section id="subsec:setassoccaches" class="level3" data-number="6.1.6">
<h3 data-number="6.1.6">Set-Associative Caches</h3>
<p>We will be focusing on a cache design that is often used in today’s CPUs, which is set-associative caches. Which means that the cache will be logically divided into <strong>Cache Sets</strong>, which will be divided into <strong>Cache Ways</strong>. Each way will store a cache line worth of data. The division of the memory into different cache sets will be a direct mapping from the memory address. Namely, each address will be associated with a cache set according to a group of bits in the address which will represent the cache set index. The specific way in which the line is fetched will be determine according to the cache replacement policy, since the cache set is expected to be full. An abstraction can be seen in</p>
<figure>
<img src="../media/file64.png" id="fig:SetWay" alt="Set-Associative Cache - The set index of a line derives from the set index bits of the address. The cache way is determine according to the cache replacement policy." /><figcaption aria-hidden="true">Set-Associative Cache - The set index of a line derives from the set index bits of the address. The cache way is determine according to the cache replacement policy.</figcaption>
</figure>
<p>Consider the following example: The cache has 8B cache lines, 16 cache sets each consisting of 2 ways. We can compute the set index of the address <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>1011111110</mn><msub><mo stretchy="false" form="postfix">)</mo><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">(1011111110)_b</annotation></semantics></math> by only looking at bits <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>3</mn></msub><mo>,</mo><msub><mi>b</mi><mn>4</mn></msub><mo>,</mo><msub><mi>b</mi><mn>5</mn></msub><mo>,</mo><msub><mi>b</mi><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">b_3, b_4, b_5, b_6</annotation></semantics></math>, since we have 16 cache sets (4 bits) and 8 different cache line offset (bits <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>,</mo><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_0, b_1, b_2</annotation></semantics></math>). Hence the cache set will be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>1111</mn><msub><mo stretchy="false" form="postfix">)</mo><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">(1111)_b</annotation></semantics></math>. We can also compute the size of the whole cache by multiplying the cache dimensions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>16</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">8 \times 16 \times 2 = 256</annotation></semantics></math>B.</p>
</section>
<section id="subsec:addrorphysicaladdr" class="level3" data-number="6.1.7">
<h3 data-number="6.1.7">Virtual Addresses or Physical Addresses</h3>
<p>Since we need the bits of address to determine its cache set, we are face with a problem due to the fact that programs running are only aware to the virtual addresses while the hardware side is aware to the physical addresses. The translation between virtual addresses and physical addresses is the responsibility of the MMU (Memory Management Unit).</p>
<p>There are four major ways of implementing such cache mapping according to the addresses. <strong>VIVT</strong> - Virtually-Indexed, virtually-Tagged. Meaning that there is no need to translate the addresses in order to know the mapping of the addresses into the cache, which is faster. On the other hand, such implementation causes aliasing issues as same virtual address maps to several different physical addresses. This aliasing is due to the tag not being unique, and will force a flush action to the entire cache on context switching. <strong>VIPT</strong> - Virtually-Indexed, Physically-Tagged. Meaning that there will be a need for TLB translation for the tag, but can be looked up in parallel. Such mapping can be quiet fast. Moreover, if the set index bits are derived from the page offset, there is no aliasing, but the cache size is limited to the page size multiply by the number of cache sets. VIPT is used in Intel’s L1 caches, with the default page size being 4K and each cache line is 64B, resulting in no larger than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">2^6 = 64</annotation></semantics></math> sets. <strong>PIPT</strong> - Physically-Indexed, Physically-Tagged. Meaning that the translation between virtual and physical addresses will have to be preformed, taking up time. On the other hand, no aliasing issues occurs and no required limitation on the number of sets is present. Typically used in the larger Intel caches - L2 and L3. <strong>PIVT</strong> - Physically-Indexed, Virtually-Tagged. Meaning that all the limitations of previous ways apply, and is rarely used in practice.</p>
</section>
<section id="subsec:replacementpolicy" class="level3" data-number="6.1.8">
<h3 data-number="6.1.8">Replacement Policy</h3>
<p>We need to decide on a policy according to which a cache line will be evicted in order to make room for incoming data. Many replacement policies exist, namely FIFO (first in, first out), LRU (least recently used), LFU (least frequently used), random, a hybrid and more.</p>
<p>Intel commonly applies a LRU policy or a pseudo-LRU policy (since pure LRU is complex to implement). Which determines that the oldest cache line to be referenced will be evicted, As if each cache line is attached with a time-stamp that is updated on access. An example can be thought of by having <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> way cache set and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> different lines of memory that are mapped into the same cache set and are accessed in order. The first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,\dots,n</annotation></semantics></math> lines will fill the cache ways, while the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> access will evict the first memory line from the set, since all the set ways are full.</p>
<p>A potential issue arises with LRU policy when a program needs to access cyclically <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math> memory lines (“program working set") that are mapped to the same <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> way cache set. This is referenced as a ’set thrashing’ and will result in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">0\%</annotation></semantics></math> hit rate. If we compare LRU policy to a random policy, depending on the workload, some studies have shown that LRU and random replacement policies have the same hit rate on average.</p>
<p>Recent studies have tried to predict intel’s CPU eviction policy for the LLC. The researchers suggest the following policy; Each cache set has an array in the same size of ways, that holds 3 bits per cell (a number between 0 to 3). When a new line is loaded into a L3 cache set, the suitable cell in the array is updated to the value 3. The array values are referred as the "age" of each line in the set. Each time a line in the cache is being accessed, the CPU searches for it in L1, if it doesn’t find it there it will search for it in L2, if both of them will result as miss, the CPU will search in L3. In case the line is found for the first time in L3 cache, it will decrease the age of this line by 1. When a new line (not in the cache) is accessed, and an eviction needs to be made, the CPU checks the age array (in the suitable cache set), and evicts the first line that it’s age is 3, if no line has the age 3, it evicts the first highest age that was found. Moreover, the researchers suggest that the processor has another policy, which enters the lines with the age of 2.</p>
<p>When implementing a cache side-channel attack, we will normally want to evict some special memory location from the cache. Considering a non-LRU replacement policy will mean that evicting a memory line from the cache will not necessarily be practical, since there is no guaranty that if the attacker accesses memory locations in a specific pattern we will evict the whole set from the cache.</p>
</section>
<section id="subsec:cachesonintelcpus" class="level3" data-number="6.1.9">
<h3 data-number="6.1.9">Caches on Intel CPUs</h3>
<figure>
<img src="../media/file65.png" id="fig:IntelCPU" alt="Basic Intel CPU - each core has its own L1 and L2 caches, while all connected to a larger sliced L3 cache which can be accessed from all cores. " /><figcaption aria-hidden="true">Basic Intel CPU - each core has its own L1 and L2 caches, while all connected to a larger sliced L3 cache which can be accessed from all cores. </figcaption>
</figure>
<p>In we can see an abstraction of an Intel CPU architecture, on which every core has its own dedicated L1 instruction and data cache, in addition to a slightly bigger L2. All cores are connected via an interconnected bus to the last level cache (LLC/L3). The LLC is often sliced into the number of cores, having a dedicated slice to each core, while having all cores being able to access all slices. The common practice is that the different levels of caches are inclusive, meaning that a lower level cache is a super-set of the higher ones.</p>
<p>In order to preform a cache side-channel attack, an attacker can optimize its cache usage, among other things, using the following command: <code>prefetch</code> - A suggestion to the CPU that some memory line will be accessed soon, can trigger fetching that line into the cache by the CPU. <code>clflush</code> - Cache line flush, instructs the CPU to flush a memory line from all levels of the cache. The two instructions are based on virtual address.</p>
<p>The different latencies of the different cache levels, as well as the timing difference between a cache miss and a cache hit (as can be seen in ), are the main primitives of most cache side-channel attacks that will be discussed by the end of this chapter.</p>
</section>
</section>
<section id="sec:cacheattackstech" class="level2" data-number="6.2">
<h2 data-number="6.2">Cache Attacks Techniques</h2>
<p>Microarchitectural attacks exploit hardware properties that allow inferring information on other processes running on the same system. In particular, cache attacks exploit the measurable timing difference between the CPU cache and the main memory. They have been the most studied microarchitectural attacks for the past 20 years, and were found to be powerful to derive cryptographic secrets <span class="citation" data-cites="Percival2009"></span>. In such attacks, the attacker monitors which memory lines are accessed, not the content of a certain memory line.</p>
<p>Cache attacks are being used in one of the two following common scenarios:</p>
<ul>
<li><p><strong>Covert channel</strong>: two processes communicating with each other when they are not allowed to do so, e.g., across VMs.</p></li>
<li><p><strong>Side channel attack</strong>: one malicious process spies on benign processes, e.g., steals crypto keys, spies on keystrokes etc.</p></li>
</ul>
<p>We will focus on side-channel attacks.</p>
<section id="subsec:cachesidechanneltiming" class="level3" data-number="6.2.1">
<h3 data-number="6.2.1">Cache Side-Channel Timing Attacks</h3>
<p>Every timing attack works by the following steps:</p>
<ol>
<li><p>Learning timing of different <em>corner cases</em>.</p></li>
<li><p>Recognizing these corner cases by timing only.</p></li>
</ol>
<p>Here, our corner cases are <em>hits</em> and <em>misses</em>.</p>
<section id="subsubsec:buildingthehistogram" class="level4" data-number="6.2.1.1">
<h4 data-number="6.2.1.1">Building the Histogram</h4>
<p>The first step towards the attack is to build the histogram of the corner cases, cache hits and cache misses. We measure the time for each case many times in order to get rid of noise. Thus, we have a histogram and we can find a threshold to distinguish the two cases.</p>
<p>Building the histogram for cache hits is done by the following loop:</p>
<ol>
<li><p>Measure time.</p></li>
<li><p>Access variable (always cache hit).</p></li>
<li><p>Measure time again.</p></li>
<li><p>Update histogram with delta.</p></li>
</ol>
<p>Building the histogram for cache misses is done by the following loop:</p>
<ol>
<li><p>Flush variable (<code>clflush</code> instruction).</p></li>
<li><p>Measure time.</p></li>
<li><p>Access variable (always cache miss).</p></li>
<li><p>Measure time again.</p></li>
<li><p>Update histogram with delta.</p></li>
</ol>
<p>Having the two histograms, as in , we determine the threshold to be as high as possible such that there will be no cache misses below.</p>
<figure>
<img src="../media/file66.jpg" id="fig:cache_hits_misses_hist" alt="Timing differences histogram of cache hits and cache misses." /><figcaption aria-hidden="true">Timing differences histogram of cache hits and cache misses.</figcaption>
</figure>
</section>
<section id="subsubsec:howtomeasuretimeaccuractely" class="level4" data-number="6.2.1.2">
<h4 data-number="6.2.1.2">How to Measure Time Accurately</h4>
<p>Consider the fact that the time intervals of our cases are (relatively) very short timings, we ask how to measure time accurately. For such short timings, it is common to use the Time Stamp Counter (TSC) via the unprivileged <code>rdtsc</code> instruction as following: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo><mo>→</mo><mtext mathvariant="monospace">𝚛𝚜𝚝𝚜𝚌</mtext><mo>→</mo><mtext mathvariant="normal">function()</mtext><mo>→</mo><mtext mathvariant="monospace">𝚛𝚜𝚝𝚜𝚌</mtext><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[...] \rightarrow \texttt{rstsc} \rightarrow \mbox{function()} \rightarrow
\texttt{rstsc} \rightarrow [...]</annotation></semantics></math> By using this instruction, due to out-of-order execution, the actual execution order could be different, resulting with wrong measurements. The solution is to use the pseudo-serializing instruction <code>rdtscp</code> or to insert a serializing instruction like <code>cpuid</code> or use fence instructions like <code>mfence</code> <span class="citation" data-cites="benchmark2010"></span>.</p>
<p>We will now introduce two main cache attack techniques: Flush+Reload <span class="citation" data-cites="Gullasch:2011:CGB:2006077.2006784 Osvik:2006:CAC:2117739.2117741 Yarom2014"></span> and Prime+Probe <span class="citation" data-cites="Percival2009 Osvik:2006:CAC:2117739.2117741 Liu:2015:LCS:2867539.2867673"></span>. Both of them are exploitable on x86 and ARM and can be used for both covert channels and side-channel attacks.</p>
</section>
</section>
<section id="subsec:flushreload" class="level3" data-number="6.2.2">
<h3 data-number="6.2.2">Flush+Reload</h3>
<p>The attack is made of four basic steps and it goes as following:</p>
<ol>
<li><p><strong>Map.</strong> The attacker maps a shared library (Illustration in ), by doing that he will have a shared cache line with the victim.</p></li>
<li><p><strong>Flush.</strong> The attacker <em>flushes</em> the shared cache line, it can be done via unprivileged instruction like <code>clflush</code>.</p></li>
<li><p><strong>Victim.</strong> The attacker lets the victim load (or not load) the shared line, depending on the victim’s behaviour.</p></li>
<li><p><strong>Reload.</strong> The attacker reloads the shared cache line. If the cache line has a <em>hit</em> the attacker infers that the victim loaded the data on the previous step, if the cache line has a <em>miss</em> the attacker infers that the victim did not load the data on the previous step.</p></li>
</ol>
<figure>
<img src="../media/file67.jpg" id="fig:fr_sharedlib" alt="Attacker maps shared library (shared memory, in cache), the shared cache line is marked in red" /><figcaption aria-hidden="true">Attacker maps shared library (shared memory, in cache), the shared cache line is marked in red</figcaption>
</figure>
<figure>
<img src="../media/file68.png" id="fig:fr_flow" alt="Flush+Reload attack flow. Between the first flush and the first reload the victim did not access the shared cache line, so the first reload resulted with a cache hit. Then, after the second flush the victim accessed the shared cache line and hence, the second reload resulted with a miss." /><figcaption aria-hidden="true">Flush+Reload attack flow. Between the first flush and the first reload the victim did not access the shared cache line, so the first reload resulted with a cache hit. Then, after the second flush the victim accessed the shared cache line and hence, the second reload resulted with a miss.</figcaption>
</figure>
<p>The first step (Mapping a shared library) can be done once, while steps 2-4 are repeatable as much as the attacker wants. The main advantage of this attack technique is the fine granularity, which is 1 memory line (usually 64B). On the other hand, this technique is somewhat restrictive, it needs <code>clflush</code> instruction, which is not always available e.g., on ARM-v7 and it needs a shared memory. Illustration of the attack flow in .</p>
<section id="subsubsec:sharedmemory" class="level4" data-number="6.2.2.1">
<h4 data-number="6.2.2.1">Shared Memory</h4>
<p>A common method to achieve a shared memory is by a feature called <em>page-deduplication</em>. When two different independent processes are loading the same system library, some of their memory pages will be identical, when the operating system (in a cloud scenario - the hypervisor) identify separate identical physical memory pages, if page-deduplication is enabled, it will merge the physical pages in order to save physical memory, and two different virtual memory pages, one of each process, will be mapped into the same physical memory page. As of today, no serious cloud service company is using memory deduplication, e.g., Amazon EC2.</p>
</section>
<section id="subsubsec:evictreload" class="level4" data-number="6.2.2.2">
<h4 data-number="6.2.2.2">Evicts+Reload</h4>
<p><span class="citation" data-cites="Gruss2015"></span> demonstrated a substitution attack for Flush+Reload that does not require using a clflush instruction. This attack access physically congruent addresses in a large array, which is placed in large pages by the operating system. In order to compute physically congruent addresses, we need to determine the lowest 18 bits of the physical address to attack, which can then be used to evict specific cache sets.</p>
</section>
</section>
<section id="subsec:primeprobe" class="level3" data-number="6.2.3">
<h3 data-number="6.2.3">Prime+Probe</h3>
<p>First, for the Prime+Probe attack to work, the Last-Level-Cache (LLC) should be inclusive, i.e., the LLC is a superset of the L1 cache and the L2 cache. Thus, data evicted from the LLC is also evicted from L1 and L2. In inclusive caches, a core can evict lines in the private L1 of another core. The attack is made of the three following steps:</p>
<ol>
<li><p><strong>Prime.</strong> The attacker primes the cache by reading memory lines from its own exclusive memory (no shared memory).</p></li>
<li><p><strong>Victim.</strong> The attacker lets the victim evict (or not evict) lines while running, depending on the victim’s behavior.</p></li>
<li><p><strong>Probe.</strong> The attacker probes data in a similar way of the prime step but with the measurement of how much time it takes to load the lines (Hit / Miss), for each cache set, the attacker determines if the cache set has been accessed.</p></li>
</ol>
<figure>
<img src="../media/file69.jpg" id="fig:pp_flow" alt="Prime+Probe flow." /><figcaption aria-hidden="true">Prime+Probe flow.</figcaption>
</figure>
<p>In comparison to Flush+Reload, this attack technique is less restrictive: it does not require <code>clflush</code>, does not assume shared memory and possible from JavaScript. On the other hand, the granularity is coarser: 1 set. Illustration of the attack flow in .</p>
<p>In practice, we need to evict caches lines without <code>clflush</code> or shared memory, so the following questions arise:</p>
<ul>
<li><p>Which addresses do we access to have congruent cache lines?</p></li>
<li><p>How do we do that without any privilege?</p></li>
<li><p>In which order do we need to access them?</p></li>
</ul>
<p>To achieve that, we need an <em>eviction set</em>: addresses in the same set, in the same slice and an <em>eviction strategy</em>.</p>
<section id="subsubsec:evictionset" class="level4" data-number="6.2.3.1">
<h4 data-number="6.2.3.1">Eviction Set</h4>
<p><a href="#fn1" class="footnote-ref" id="fnref1" epub:type="noteref">1</a> We want to target the L3 for cross-core attacks and we need addresses that have the same set index. Consider the following cache settings, L3 for a 2-core CPU: 4096 sets, 64B-lines, 12 or 16 ways. Since each memory address indicates one memory byte, the 6 least significant bits of the physical address indicates the line offset. For simplicity, we assume that the cache is not sliced, since there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4096</mn><mo>=</mo><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">4096=2^{12}</annotation></semantics></math> cache sets, and the next 12 bits indicate the cache set. The L3 is physically indexed, so we need to choose addresses with fixed physical address bits. Unfortunately, address translation from virtual to physical is privileged. One of the virtual addresses’ properties is that a page offset stays the same from virtual to physical address. Thus, some of the least significant bits of the virtual address can be used as a sneak peek to the physical address. Typical page size is 4KB, which means just 12 bits of page offset, i.e., 6 bits of line offset and 6 least significant bits of the cache set out of 12. To overcome this limitation, we can use a special type of enlarged pages called <em>Huge Pages</em>, which are 2MB size each, that is - 21 bits of page offset. This way, the set index bits are included in the 21 LSB of the address.</p>
<p>We now have another issue; in practice, the L3 is divided into slices, as many slices as cores. We usually have 2048 sets per slice, that is, actually 11 bits for the set index. We cannot infer the slice number directly from the address, neither from the virtual or the physical. The slice number of each memory line is determined by a hash function, which takes all the address bits as input, including physical page number bits (outside the known bits from page offset). The Illustration below shows the address bit indication for both typical pages and huge pages.</p>
<figure>
<img src="../media/file70.jpg" id="fig:slicedcache" alt="Sliced cache." /><figcaption aria-hidden="true">Sliced cache.</figcaption>
</figure>
<p>Also, the mentioned hash function is undocumented; it designed for performance. But, it does not mean that it is impossible to target the same set in the same slice. Previous work <span class="citation" data-cites="EURECOM+4671"></span> showed that the hash function could be reverse engineered, for example, in .</p>
<figure>
<img src="../media/file71.jpg" id="fig:hashfunc" alt="Three reversed engineered hash functions, depending on the number of cores. Function valid for Sandy Bridge, Ivy Bridge, Haswell, Broadwell" /><figcaption aria-hidden="true">Three reversed engineered hash functions, depending on the number of cores. Function valid for Sandy Bridge, Ivy Bridge, Haswell, Broadwell</figcaption>
</figure>
<p>If the function is unknown, the process will be somewhat slower. But an eviction set can still be achieved via the following algorithm:</p>
<ol>
<li><p>Construct <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>, set of addresses with the same set index.</p></li>
<li><p>Access reference address <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">x \in S</annotation></semantics></math> (to load it in cache).</p></li>
<li><p>Iteratively access all elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p></li>
<li><p>Measure <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>1</mn></msub><annotation encoding="application/x-tex">t_1</annotation></semantics></math>, the time it takes to access <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. it should be evicted.</p></li>
<li><p>Select a random address <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> and remove it.</p></li>
<li><p>Iteratively access all elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>\<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.</p></li>
<li><p>Measure <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>2</mn></msub><annotation encoding="application/x-tex">t_2</annotation></semantics></math>, the time it takes to access <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> - is it evicted?</p>
<ul>
<li><p>If not, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> is part of the same set as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, place it back into <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>.</p></li>
<li><p>If it was evicted, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> is not part of the same set as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, discard <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.</p></li>
</ul></li>
</ol>
<p>Note that for a CPU with c cores: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">16/c</annotation></semantics></math> addresses in the same set and slice per 2MB page, we can apply the same algorithm with groups of addresses instead of single addresses and speed up the eviction set building process by up to three orders of magnitude.</p>
</section>
<section id="subsubsec:EvictionStrategy" class="level4" data-number="6.2.3.2">
<h4 data-number="6.2.3.2">Eviction Strategy</h4>
<p>In the Prime or the Probe step, the attacker evicts a cache set by filling it with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> addresses for a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-way cache. If the replacement policy is LRU, it access addresses from eviction set 1 by 1. If the replacement policy is not LRU, the eviction rate is lesser than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math>, e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>75</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">75\%</annotation></semantics></math> on Haswell. For non-LRU caches, we can use some heuristics, as in , that will result in a higher eviction rate.</p>
<figure>
<img src="../media/file72.jpg" id="fig:haswellstrategy" alt="a_1\dots a_9 are in the same cache set. Fast and effective on Haswell: eviction rate &gt; 99.97\%" /><figcaption aria-hidden="true"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi>…</mi><msub><mi>a</mi><mn>9</mn></msub></mrow><annotation encoding="application/x-tex">a_1\dots a_9</annotation></semantics></math> are in the same cache set. Fast and effective on Haswell: eviction rate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>99.97</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">&gt; 99.97\%</annotation></semantics></math></figcaption>
</figure>
</section>
<section id="subsubsec:Conclusion" class="level4" data-number="6.2.3.3">
<h4 data-number="6.2.3.3">Conclusion</h4>
<p>To sum it up, in practice, for Prime+Probe on recent processors we need:</p>
<ul>
<li><p>An eviction set, i.e., addresses in the same slice and with the same set index. Depends on the addressing.</p></li>
<li><p>An eviction strategy, i.e., the order with which we access the eviction set. Depends on the replacement policy</p></li>
</ul>
</section>
</section>
<section id="subsec:Hardwarevsimplementations" class="level3" data-number="6.2.4">
<h3 data-number="6.2.4">Hardware vs. implementations</h3>
<p>To perform a cache side-channel attack on some software, you need two things: First, shared and vulnerable hardware. Note that there will be no side-channel if every memory access takes the same time or if you cannot share the hardware component. Second, a vulnerable implementation. Note that a vulnerable implementation does not mean that the algorithm is vulnerable. For example, we can take the specific implementation of AES and RSA, this does not imply that AES and RSA are defective. Not all implementations are created equal.</p>
<p>To sum up, hardware will most likely stay vulnerable, so patch implementations when you can. And remember, constant time is not enough - because an attacker can modify the internal state of the micro-architecture.</p>
</section>
</section>
<section id="sec:stepbystepattack" class="level2" data-number="6.3">
<h2 data-number="6.3">Step by Step Attack Demo</h2>
<p>The target of the attack in this demonstration is to get the timestamp of the keystrokes pressed by a user in a gedit program. We only target the timestamps and not the keystrokes themselves, as we cannot fully recover the pressed keys.</p>
<p>The demonstration is performed on a non-virtualized Linux environment. A requirement to perform the attack is having an Intel CPU, as we need the inclusive property of the L3 cache. The code for performing the attack can be cloned from the git repository <span class="citation" data-cites="GitClementine"></span>. It is based on the Flush+Reload cache attack that we mentioned in <a href="ch007.xhtml#subsec:flushreload" data-reference-type="ref" data-reference="subsec:flushreload">6.2.2</a> presented in <span class="citation" data-cites="Yarom2014"></span> and <span class="citation" data-cites="Gruss2015"></span>.</p>
<p>The attack is performed in 3 steps: calibration, profiling and exploit. For each of these steps, a folder exists in the repository.</p>
<section id="subsec:step1calibration" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1">Step 1: Calibration</h3>
<p>In this step, we want to create the histogram, which depicts the cache misses and hits as a function of the number of CPU cycles. Then we will be able to extract the threshold that will match the CPU on which we perform the attack. In order to perform the calibration, we run the following commands:</p>
<div class="sourceCode" id="cb1" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>$ <span class="bu">cd</span> calibration</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  $ <span class="fu">make</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  $ <span class="ex">./calibration</span></span></code></pre></div>
<p>The calibration works by generating multiple cache misses and cache hits and measuring the number of CPU cycles it takes to access a variable. Each of these cases is being performed multiple times in order to get rid of the noise.</p>
<p>We build a histogram of cache hits and cache misses as described in previous <a href="ch007.xhtml#subsubsec:buildingthehistogram" data-reference-type="ref" data-reference="subsubsec:buildingthehistogram">6.2.1.1</a>. The output of the calibration program is a histogram of the cache misses and hits as shown in .</p>
<p>We can then find the threshold so it satisfies the following requirements:</p>
<ol>
<li><p>As high as possible</p></li>
<li><p>Most cache hits are below it</p></li>
<li><p>No cache miss below (we may see one exception due to the way the calibration is coded)</p></li>
</ol>
<p>For example, in , we can see that there is a clear line in approximately <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>220</mn><annotation encoding="application/x-tex">220</annotation></semantics></math> CPU cycles.</p>
</section>
<section id="subsec:step2profiling" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2">Step 2: Profiling</h3>
<p>After finding the threshold, we can now profile in order to find the cache lines that are useful to get information about the target program. Choosing gedit as the target program, we first need to find the shared library that it uses so that we can give it as an input to the profiler. We then need to find this shared library file location and size. In order to do that, we can use the following one-liner:</p>
<pre><code>$ cat /proc/`ps -A | grep gedit | grep -oE &quot;^[0-9]+&quot;`/maps | grep r-x | grep libgedit</code></pre>
<p>This is equivalent to first finding the pid with</p>
<div class="sourceCode" id="cb3" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>$ <span class="fu">ps</span> -A <span class="kw">|</span> <span class="fu">grep</span> gedit</span></code></pre></div>
<p>and then using this pid in</p>
<div class="sourceCode" id="cb4" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>$ <span class="fu">cat</span> /proc/<span class="op">&lt;</span>pid<span class="op">&gt;</span>/maps <span class="kw">|</span> <span class="fu">grep</span> libgedit</span></code></pre></div>
<p>then copying the line with r-xp permissions (x stands for executable).</p>
<p>Doing that gives the following line (memory range, access rights, offset, –, –, file name):</p>
<div class="sourceCode" id="cb5" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">7f2d83197000-7f2d8326d000</span> r-xp 00000000 08:02 1080575             /usr/lib/gedit/libgedit.so</span></code></pre></div>
<p>We need to update the threshold to the value we found in the calibration step before we can feed the above line to the profiler. We can do this by editing the profiler source file (under the profiling directory) and updating the line with the constant</p>
<div class="sourceCode" id="cb6" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#define MIN_CACHE_MISS_CYCLES</span></span></code></pre></div>
<p>to the threshold we have.</p>
<p>After updating the threshold, we can run <code>make</code> to compile the profiler. We then use <code>sleep 3</code> so we can have time to trigger the event before the profiler starts, and run the profiler with the line we found above:</p>
<div class="sourceCode" id="cb7" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sleep</span> 3<span class="kw">;</span> <span class="ex">./profiling</span> 200 7f2d83197000-7f2d8326d000 r-xp 00000000 08:02 1080575                    /usr/lib/gedit/libgedit.so</span></code></pre></div>
<p>The profiler does its job by loading the shared library to its address space, and then doing flushes and reloads for each address in the address range given by the offset argument (0 in the above case), and the library size (1080575 bytes) for some given time (200 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>sec for every address in the above command). The output is the number of hits that happened in every address.</p>
<p>The idea is that if a 0 is shown for a given address while triggering the event, then it means that the line in this address was never accessed for this event. Eventually, we will get lines with some cache hits, and we want the ones that have at least a non zero value when profiling.</p>
<figure>
<img src="../media/file73.png" id="fig:profiling-cache-hits" alt="Addresses with cache hits." /><figcaption aria-hidden="true">Addresses with cache hits.</figcaption>
</figure>
<p>Running the profiler with offset 0 while jamming a key, doesn’t seem to generate cache hits, and we may only see 0. The reason for that, is that the code that handles keystrokes in the library is probably just not in the beginning of the library. Instead (and this is a cheat), we change the starting offset to 20000, and this is approximately where the code that handles keystrokes in the library is found. In real life we will have to wait until we get to something by running the template attack on the whole library. Running the profiler with this new offset, we can see in some addresses that have a non-zero value quite fast. The addresses with the high numbers are the ones we should further investigate in the exploit phase.</p>
</section>
<section id="subsec:step3exploitation" class="level3" data-number="6.3.3">
<h3 data-number="6.3.3">Step 3: Exploitation</h3>
<p>Equipped with the addresses from the previous step, we can now go to the exploitation dir, change the threshold constant (MIN_CACHE_MISS_CYCLES) as we did for the profiler, and run <code>make</code>. Then we can run the program by</p>
<div class="sourceCode" id="cb8" data-language="bash"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./spy</span> <span class="op">&lt;</span>library-file<span class="op">&gt;</span> <span class="op">&lt;</span>offset<span class="op">&gt;</span></span></code></pre></div>
<p>giving one of the addresses we found as the offset argument. Starting from the address with the most hits, we can see that even if we are not pressing any key, we are still getting events. The reason for that is that this address is related to the blinking cursor. This is, of course, not really interesting information, and we can understand that it is not always the address that has the most hits that is the most valuable. Trying the next interesting address indeed gives us information about the pressed keys, which is what we wanted to achieve. However, moving the mouse also gives us a lot of hits, which is not perfect. We will need to inspect the addresses one by one until we find an address that will only work for keystrokes.</p>
<p>We can even further improve the attack by finding the complete matrix of the keystrokes for each of the keys as shown in . We can see that for different keys, there is a different “signature” of the accessed addresses. Although we may not be able to precisely identify each keystroke, we can try to group the keystrokes to different addresses and eliminate some guesses if we can spy on more than one address at a time.</p>
<figure>
<img src="../media/file74.png" id="fig:cache-keymap-matrix" style="width:80.0%" alt="Complete matrix for each keystroke." /><figcaption aria-hidden="true">Complete matrix for each keystroke.</figcaption>
</figure>
<p>Finally, as it may be annoying to perform the above process manually, we can automate the event triggering and other stuff as shown in <span class="citation" data-cites="GitGruss"></span>.</p>
</section>
</section>
<section id="sec:Cache Template Attacks Paper" class="level2" data-number="6.4">
<h2 data-number="6.4">Cache Template Attacks Paper</h2>
<ul>
<li><p><strong>Cache Template Attacks Paper</strong> - The article is called “Cache Template Attacks: Automating Attacks on Inclusive Last-Level Caches” by Daniel Gruss et el. Cache Template Attacks consist of two phases. In the profiling phase, they determine dependencies between the processing of secret information and specific cache accesses. In the exploitation phase, they derive the secret values based on observed cache accesses. Among the presented attacks is the application of Cache Template Attacks to infer keystrokes and—even more severe—the identification of specific keys on Linux and Windows user interfaces. Furthermore, they perform an automated attack on the Ttable-based AES implementation of OpenSSL that is as efficient as state-of-the-art manual cache attacks.</p>
<p><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-gruss.pdf">Cache Template Attacks Paper</a>.</p></li>
</ul>
</section>
</section>
<section class="footnotes" epub:type="footnotes">
<hr />
<ol>
<li id="fn1" epub:type="footnote"><p>From now on, most of the details are correct for a common Intel CPU architecture.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
